# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dU8tq5f7WAau0bwLTX1BFG51-UzJnubK
"""

# Colab 進行matplotlib繪圖時顯示繁體中文
# 下載台北思源黑體並命名taipei_sans_tc_beta.ttf，移至指定路徑
!wget -O TaipeiSansTCBeta-Regular.ttf https://drive.google.com/uc?id=1eGAsTN1HBpJAkeVM57_C7ccp7hbgSz3_&export=download

# @title 預設標題文字
# 研發計畫亮點突破排序分析程式碼 (最終版)
# 用於分析Excel檔案並排出Top 50亮點技術案例

import pandas as pd
import numpy as np
import re
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from collections import Counter
import warnings
warnings.filterwarnings('ignore')  # 忽略警告訊息


# 設定顯示中文
matplotlib.font_manager.fontManager.addfont('TaipeiSansTCBeta-Regular.ttf')
matplotlib.rc('font', family='Taipei Sans TC Beta')
plt.rcParams['axes.unicode_minus'] = False

#plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei']  # 微軟正黑體
#plt.rcParams['axes.unicode_minus'] = False  # 解決座標軸負號顯示問題

#======================================================================
# 1. 基礎工具函數
#======================================================================

def clean_column_name(col_name):
    """
    清理欄位名稱，移除特殊字元並標準化

    Args:
        col_name: 原始欄位名稱

    Returns:
        str: 清理後的欄位名稱
    """
    if isinstance(col_name, str):
        # 移除換行符並去除前後空格
        cleaned = col_name.replace('\r\n', ' ').strip()
        return cleaned
    return col_name

def find_column_by_keyword(df, keywords, must_contain=None, fallback_keywords=None):
    """
    根據關鍵詞尋找符合的欄位

    Args:
        df: DataFrame
        keywords: 欄位可能包含的關鍵詞列表
        must_contain: 欄位必須包含的關鍵詞 (None表示不要求)
        fallback_keywords: 找不到時使用的備用關鍵詞

    Returns:
        list: 找到的欄位名稱列表
    """
    found_cols = []

    # 首先尋找同時包含所有關鍵詞和必要關鍵詞的欄位
    for col in df.columns:
        col_clean = clean_column_name(col)
        if must_contain and must_contain not in col_clean:
            continue

        if all(kw in col_clean for kw in keywords):
            found_cols.append(col)

    # 若找不到完全符合的，尋找包含任意一個關鍵詞和必要關鍵詞的欄位
    if not found_cols:
        for col in df.columns:
            col_clean = clean_column_name(col)
            if must_contain and must_contain not in col_clean:
                continue

            if any(kw in col_clean for kw in keywords):
                found_cols.append(col)

    # 若仍找不到，使用備用關鍵詞
    if not found_cols and fallback_keywords:
        for col in df.columns:
            col_clean = clean_column_name(col)
            if any(kw in col_clean for kw in fallback_keywords):
                found_cols.append(col)

    return found_cols

def find_evidence_columns(df):
    """
    尋找DataFrame中的佐證資料相關欄位

    Args:
        df: 包含論文資訊的DataFrame

    Returns:
        list: 佐證資料相關欄位名稱列表
    """
    # 尋找「佐證資料」相關欄位
    evidence_cols = find_column_by_keyword(
        df,
        ['佐證', '資料'],
        must_contain='佐證',
        fallback_keywords=['論文', '專利', '證明']
    )

    return evidence_cols

def define_keywords():
    """
    定義用於評分的關鍵詞列表

    Returns:
        dict: 包含不同類別關鍵詞的字典
    """
    # 突破性相關關鍵詞
    breakthrough_keywords = [
        '首創', '創新', '獨特', '突破', '優於', '提升', '改善', '高效', '精準',
        '領先', '超越', '卓越', '革命性', '顛覆', '先進', '最佳', '開創', '前沿',
        '最高', '最準', '最快', '最優', '最低', '最小', '最大', '最強'
    ]

    # 應用相關關鍵詞
    application_keywords = [
        '商業化', '產品化', '應用', '場域', '市場', '效益', '成本降低', '收益',
        '經濟', '產業', '客戶', '服務', '解決方案', '需求', '使用者', '輔助',
        '落地', '實用', '實證', '實踐', '量產', '上市', '推廣', '營收'
    ]

    # 認證相關關鍵詞
    certification_keywords = [
        '專利', '證書', 'FDA', 'CE', '認證', '許可', '標準', '規範',
        '核准', '授權', '法規', '符合', '通過', '驗證', 'ISO', 'GMP',
        'TFDA', '藥證', '醫材'
    ]

    # 場域相關關鍵詞
    field_keywords = [
        '醫院', '學校', '工廠', '企業', '政府', '機構', '試驗', '測試',
        '驗證', '場域', '臨床', '實驗室', '商場', '社區', '居家', '公司',
        '中心', '部門', '機關', '單位'
    ]

    # 痛點與解決方案關鍵詞
    solution_keywords = [
        '解決', '改善', '減輕', '降低', '提升', '增強', '優化', '取代',
        '突破', '消除', '克服', '應對', '對應', '挑戰', '問題', '難題',
        '痛點', '缺點', '缺陷', '限制'
    ]

    # 返回關鍵詞字典
    return {
        'breakthrough': breakthrough_keywords,
        'application': application_keywords,
        'certification': certification_keywords,
        'field': field_keywords,
        'solution': solution_keywords
    }

#======================================================================
# 2. 資料讀取與探索
#======================================================================

def load_data(file_path):
    """
    讀取Excel檔案，返回DataFrame，並處理欄位名稱中的特殊字元

    Args:
        file_path: Excel檔案路徑

    Returns:
        pandas.DataFrame: 包含研發計畫亮點資料的DataFrame
    """
    print(f"正在讀取檔案: {file_path}")
    try:
        # 嘗試讀取Excel檔案，首先嘗試自動檢測工作表
        df = pd.read_excel(file_path)

        # 如果沒有找到資料或欄位太少，嘗試指定工作表名稱
        if len(df.columns) < 5:
            xls = pd.ExcelFile(file_path)
            sheets = xls.sheet_names
            print(f"檔案中的工作表: {sheets}")

            # 嘗試可能的工作表名稱
            for sheet in sheets:
                if '團隊' in sheet or '資料' in sheet or '原始' in sheet:
                    df = pd.read_excel(file_path, sheet_name=sheet)
                    print(f"使用工作表: {sheet}")
                    break

        # 處理欄位名稱中的特殊字元 (\r\n)
        new_columns = {}
        for col in df.columns:
            # 替換 \r\n 為空格
            if isinstance(col, str):
                new_col = col.replace('\r\n', ' ').strip()
                if new_col != col:
                    new_columns[col] = new_col

        # 如果有需要替換的欄位名稱，進行替換
        if new_columns:
            df = df.rename(columns=new_columns)
            print("已清理欄位名稱中的特殊字元")

        print(f"成功讀取檔案，共 {len(df)} 筆資料")
        print(f"資料欄位數量: {len(df.columns)}")

        # 檢查是否有必要的資料欄位
        essential_keywords = ['技術', '項次', '組別']
        has_essential = False
        for keyword in essential_keywords:
            if any(keyword in clean_column_name(col) for col in df.columns):
                has_essential = True
                break

        if not has_essential:
            print("警告: 未找到必要的資料欄位，請檢查Excel檔案格式")

        return df
    except Exception as e:
        print(f"讀取檔案時發生錯誤: {e}")
        return None

def explore_data(df):
    """
    探索資料集的基本特性

    Args:
        df: DataFrame

    Returns:
        dict: 資料集的基本特性
    """
    result = {}

    # 基本資訊
    result['資料筆數'] = len(df)
    result['欄位數'] = len(df.columns)

    # 欄位分類
    tech_cols = [col for col in df.columns if '技術' in clean_column_name(col)]
    app_cols = [col for col in df.columns if '應用' in clean_column_name(col)]
    evidence_cols = [col for col in df.columns if '佐證' in clean_column_name(col)]

    result['技術相關欄位'] = tech_cols
    result['應用相關欄位'] = app_cols
    result['佐證資料欄位'] = evidence_cols

    # 組別分布
    group_col = None
    for col in df.columns:
        if '組別' in clean_column_name(col):
            group_col = col
            break

    if group_col:
        result['組別分布'] = df[group_col].value_counts().to_dict()

    return result

#======================================================================
# 3. 論文與專利資訊提取
#======================================================================

def extract_papers_and_patents(evidence_text):
    """
    從佐證資料文字中提取論文和專利資訊

    Args:
        evidence_text: 佐證資料文字

    Returns:
        dict: 包含論文和專利資訊的字典
    """
    result = {
        'papers': [],  # 論文列表
        'patents': [], # 專利列表
        'dois': []     # DOI列表
    }

    # 移除換行符，以便更好地處理
    text = evidence_text.replace('\r\n', ' ').replace('\n', ' ')

    # 1. 識別並提取論文資訊
    # 尋找以數字編號開頭的項目，如 "1. Author et al. "Title" Journal (Year)"
    numbered_items = re.findall(r'\d+\.\s+([^\.]+\.[^\.]+\.[^\d]+\(\d{4}\))', text)
    if numbered_items:
        for item in numbered_items:
            # 檢查是否確實是論文（含有引號包圍的標題）
            if re.search(r'["\'「」]', item):
                result['papers'].append(item.strip())

    # 查找引號包圍的論文標題
    paper_titles = re.findall(r'["\'「]([^"\'」]+)["\'\」]', text)
    # 尋找完整的論文引用格式
    potential_citations = re.findall(r'[\w\s]+et al\.?\s+[\w\s]*["\'「].*?["\'\」].*?\(\d{4}\)', text)

    # 匹配DOI
    dois = re.findall(r'doi:(\S+)', text, re.IGNORECASE) + re.findall(r'DOI:?\s*(\S+)', text)
    if dois:
        result['dois'].extend(dois)

    # 處理可能的論文引用
    if potential_citations:
        for citation in potential_citations:
            if citation not in result['papers']:
                result['papers'].append(citation.strip())
    elif paper_titles and not result['papers']: # 如果沒有找到完整引用但有標題
        for title in paper_titles:
            # 尋找包含此標題的較大文本段落
            surrounding_text = re.findall(r'[^.]*["\'「]' + re.escape(title) + r'["\'\」][^.]*\.', text)
            if surrounding_text:
                for context in surrounding_text:
                    if context not in result['papers']:
                        result['papers'].append(context.strip())
            else:
                # 如果沒有找到上下文，至少保存標題
                result['papers'].append(title)

    # 2. 識別並提取專利資訊
    # 匹配常見的專利標識格式
    patent_patterns = [
        r'專利.{0,20}[:：]?\s*([A-Z0-9]+)',  # 專利證書號:I849690
        r'證書號.{0,10}[:：]?\s*([A-Z0-9]+)', # 證書號:I849690
        r'專利號碼.{0,10}[:：]?\s*([A-Z0-9]+)', # 專利號碼:I849690
        r'([A-Z]{1,3}\d{5,})',  # 直接的專利號，如I849690
        r'專利.*?申請中.*?申請案號[\s:：]*([A-Z0-9\/\-]+)', # 專利申請中的情況
        r'美國專利申請[案號]*[\s:：]*([0-9\/\-]+)', # 美國專利申請的情況
    ]

    for pattern in patent_patterns:
        patents = re.findall(pattern, text)
        if patents:
            for patent in patents:
                # 清理並添加專利號
                cleaned_patent = patent.strip()
                if cleaned_patent and cleaned_patent not in result['patents']:
                    result['patents'].append(cleaned_patent)

    # 3. 搜尋完整的專利描述
    patent_descriptions = re.findall(r'專利[:：]?\s*([^。]+[。])', text)
    if patent_descriptions:
        for desc in patent_descriptions:
            if '專利' in desc and desc not in result['patents']:
                result['patents'].append(desc.strip())

    return result

#======================================================================
# 4. 各項指數計算
#======================================================================

def analyze_key_metrics(text):
    """
    從科學突破性概述中分析並提取關鍵指標數值

    Args:
        text: 科學突破性概述文字

    Returns:
        float: 基於關鍵指標的分數
    """
    score = 0

    # 1. 提取所有可能的百分比值
    percentage_values = re.findall(r'(\d+\.?\d*)\s*%', text)
    percentage_values = [float(v) for v in percentage_values]

    # 2. 提取準確率/精確度相關數值
    accuracy_patterns = [
        (r'準確率[達到]*\s*(\d+\.?\d*)\s*%', 3),  # 準確率數值，權重3
        (r'精確度[達到]*\s*(\d+\.?\d*)\s*%', 3),  # 精確度數值，權重3
        (r'靈敏度[達到]*\s*(\d+\.?\d*)\s*%', 2.5), # 靈敏度數值，權重2.5
        (r'特異度[達到]*\s*(\d+\.?\d*)\s*%', 2.5), # 特異度數值，權重2.5
        (r'AUC[為是達到]*\s*(\d+\.?\d*)', 3),      # AUC值，權重3
        (r'F1[為是值達到]*\s*(\d+\.?\d*)', 2.5),   # F1分數，權重2.5
    ]

    for pattern, weight in accuracy_patterns:
        matches = re.findall(pattern, text)
        for match in matches:
            value = float(match)
            # 針對百分比值進行評分 (高於90%的準確率得分較高)
            if '%' in pattern and value > 90:
                score += weight * 1.5
            elif '%' in pattern and value > 80:
                score += weight
            elif '%' in pattern and value > 70:
                score += weight * 0.8
            elif '%' in pattern:
                score += weight * 0.5
            # 針對AUC和F1等值進行評分 (通常為0-1範圍)
            elif value > 0.9:
                score += weight * 1.5
            elif value > 0.8:
                score += weight
            elif value > 0.7:
                score += weight * 0.8
            else:
                score += weight * 0.5

    # 3. 提取效率/性能提升相關數值
    improvement_patterns = [
        (r'提升[了]?\s*(\d+\.?\d*)\s*%', 2.5),          # 提升百分比，權重2.5
        (r'增加[了]?\s*(\d+\.?\d*)\s*%', 2),            # 增加百分比，權重2
        (r'降低[了]?\s*(\d+\.?\d*)\s*%', 2),            # 降低百分比，權重2
        (r'減少[了]?\s*(\d+\.?\d*)\s*%', 2),            # 減少百分比，權重2
        (r'快[了]?\s*(\d+\.?\d*)\s*倍', 2.5),           # 速度提升倍數，權重2.5
        (r'效率[提升增加]+[了]?\s*(\d+\.?\d*)\s*%', 3),  # 效率提升百分比，權重3
        (r'效率[提升增加]+[了]?\s*(\d+\.?\d*)\s*倍', 3), # 效率提升倍數，權重3
    ]

    for pattern, weight in improvement_patterns:
        matches = re.findall(pattern, text)
        for match in matches:
            value = float(match)
            # 針對百分比提升進行評分
            if '%' in pattern:
                if value > 50:
                    score += weight * 1.5
                elif value > 30:
                    score += weight
                elif value > 10:
                    score += weight * 0.8
                else:
                    score += weight * 0.5
            # 針對倍數提升進行評分
            elif '倍' in pattern:
                if value > 5:
                    score += weight * 1.5
                elif value > 2:
                    score += weight
                else:
                    score += weight * 0.7

    # 4. 提取相關性/一致性指標
    correlation_patterns = [
        (r'相關[係數性]+[為是達到]+\s*(\d+\.?\d*)', 2),         # 相關係數，權重2
        (r'[皮爾森斯皮爾曼]相關[係數為是達到]*\s*(\d+\.?\d*)', 2), # Pearson/Spearman相關，權重2
        (r'相關性[為是達到]+\s*(\d+\.?\d*)', 1.5),             # 相關性值，權重1.5
        (r'一致性[為是達到]+\s*(\d+\.?\d*)', 1.5),             # 一致性值，權重1.5
        (r'ρ\s*=\s*(\d+\.?\d*)', 2.5),                       # ρ值，權重2.5
        (r'r\s*=\s*(\d+\.?\d*)', 2),                         # r值，權重2
    ]

    for pattern, weight in correlation_patterns:
        matches = re.findall(pattern, text)
        for match in matches:
            value = float(match)
            if value > 0.9:
                score += weight * 1.5
            elif value > 0.7:
                score += weight
            elif value > 0.5:
                score += weight * 0.7
            else:
                score += weight * 0.3

    # 5. 提取統計顯著性指標
    significance_patterns = [
        (r'p\s*[<＜]\s*0\.0+1', 3),      # p<0.001，高度顯著，權重3
        (r'p\s*[<＜]\s*0\.01', 2.5),     # p<0.01，較顯著，權重2.5
        (r'p\s*[<＜]\s*0\.05', 2),       # p<0.05，顯著，權重2
        (r'[統計]*顯著[性差異]*', 1.5),     # 提到統計顯著性，權重1.5
    ]

    for pattern, weight in significance_patterns:
        if re.search(pattern, text):
            score += weight

    # 如果科學突破性概述中沒有提及具體數值，給予基礎分數
    if score == 0 and re.search(r'[提升|改善|增強|優化|提高]', text):
        score += 1

    return score

def calculate_breakthrough_index(row, keywords):
    """
    計算科學突破指數

    Args:
        row: DataFrame的一行資料
        keywords: 關鍵詞字典

    Returns:
        float: 科學突破指數分數
    """
    # 找出科學突破性概述欄位
    breakthrough_col = None
    for col in row.index:
        col_clean = clean_column_name(col)
        if ('科學突破性' in col_clean or '突破性概述' in col_clean) and '概述' in col_clean:
            breakthrough_col = col
            break

    # 若找不到科學突破性概述欄位，查找可能的替代欄位
    if not breakthrough_col:
        for col in row.index:
            col_clean = clean_column_name(col)
            if '優勢' in col_clean or '技術簡介' in col_clean or ('技術' in col_clean and '概述' in col_clean):
                breakthrough_col = col
                break

    # 若仍找不到，返回0分
    if not breakthrough_col:
        return 0

    # 獲取「科學突破性概述」欄位文字
    text = str(row[breakthrough_col])
    score = 0

    # 智能分析數值提升，找出最相關的關鍵數值
    score += analyze_key_metrics(text)

    # 計算突破性關鍵詞出現次數
    for word in keywords['breakthrough']:
        score += text.count(word) * 1

    # 與現有技術比較的評分
    comparison_phrases = ["比較", "優於", "勝於", "超越", "相比", "對比"]
    for phrase in comparison_phrases:
        if phrase in text:
            score += 1.5

    # 技術成熟度評分
    if '驗證' in text:
        score += 3
    if '已經' in text and ('應用' in text or '實施' in text):
        score += 2

    return score

def calculate_application_index(row, keywords):
    """
    計算產業應用指數

    Args:
        row: DataFrame的一行資料
        keywords: 關鍵詞字典

    Returns:
        float: 產業應用指數分數
    """
    # 找出產業應用性概述欄位
    application_col = None
    for col in row.index:
        col_clean = clean_column_name(col)
        if ('產業應用' in col_clean or '應用性概述' in col_clean) and '概述' in col_clean:
            application_col = col
            break

    # 若找不到產業應用性概述欄位，查找可能的替代欄位
    if not application_col:
        for col in row.index:
            col_clean = clean_column_name(col)
            if '經濟效益' in col_clean or '應用' in col_clean or ('產業' in col_clean and '概述' in col_clean):
                application_col = col
                break

    # 找出痛點欄位
    pain_point_col = None
    for col in row.index:
        col_clean = clean_column_name(col)
        if '痛點' in col_clean or '待解決' in col_clean or '問題' in col_clean:
            pain_point_col = col
            break

    # 若找不到相關欄位，返回0分
    if not application_col:
        return 0

    # 獲取「產業應用性概述」欄位文字
    text = str(row[application_col])

    # 獲取痛點欄位文字（如果存在）
    pain_point = ""
    if pain_point_col:
        pain_point = str(row[pain_point_col])

    score = 0

    # 應用場域數量評分
    for word in keywords['field']:
        score += text.count(word) * 1

    # 根據痛點解決程度評分
    solution_count = 0
    for word in keywords['solution']:
        solution_count += text.count(word)

    # 根據解決痛點的程度評分
    if solution_count >= 5:
        score += 3  # 完全解決
    elif solution_count >= 3:
        score += 2  # 部分解決
    elif solution_count >= 1:
        score += 1  # 潛在解決

    # 經濟效益描述評分
    economic_patterns = [
        r'\d+\s*[萬千億兆]*[元幣美金]',
        r'\d+\s*%\s*[成長增加提升]',
        r'[降低減少節省節約]\s*\d+\s*%'
    ]

    for pattern in economic_patterns:
        if re.search(pattern, text):
            score += 3
            break
    else:
        economic_terms = ['效益', '收益', '營收', '獲利', '市場', '商機', '經濟', '節省']
        for term in economic_terms:
            if term in text:
                score += 1
                break

    # 技術推廣階段評分
    if any(term in text for term in ['已商業化', '已量產', '已上市', '已銷售']):
        score += 4
    elif any(term in text for term in ['申請認證', '申請許可', '申請專利']):
        score += 3
    elif any(term in text for term in ['擴展應用', '擴大應用', '推廣中']):
        score += 2
    elif any(term in text for term in ['概念驗證', 'POC', '原型']):
        score += 1

    return score

def calculate_evidence_index(row):
    """
    計算佐證資料強度指數

    Args:
        row: DataFrame的一行資料

    Returns:
        float: 佐證資料強度指數分數
    """
    # 找出佐證資料相關欄位
    evidence_cols = []
    for col in row.index:
        col_clean = clean_column_name(col)
        if '佐證資料' in col_clean and ('一' in col_clean or '二' in col_clean):
            evidence_cols.append(col)

    # 若找不到佐證資料欄位，尋找替代欄位
    if not evidence_cols:
        for col in row.index:
            col_clean = clean_column_name(col)
            if '論文' in col_clean or '專利' in col_clean or '佐證' in col_clean:
                evidence_cols.append(col)

    # 若仍找不到，返回0分
    if not evidence_cols:
        return 0

    # 合併佐證資料以統一評分
    all_evidence = ""
    for col in evidence_cols:
        all_evidence += str(row[col]) + " "

    # 提取論文和專利資訊
    evidence_data = extract_papers_and_patents(all_evidence)

    score = 0

    # 計算論文數量及類型分數
    papers = evidence_data['papers']
    for paper in papers:
        paper_score = 0

        # 檢測頂級期刊
        if any(journal in paper for journal in ['Nature', 'Science', 'Cell', 'NEJM', 'Lancet', 'JAMA', 'IEEE Trans', 'ACM Trans']):
            paper_score = 5  # 頂級期刊
        # 檢測SCI/SSCI期刊
        elif any(term in paper for term in ['SCI', 'SSCI', 'Journal of', 'International Journal']):
            paper_score = 3  # SCI/SSCI期刊
            # 檢測是否有提及影響因子(IF)
            if re.search(r'IF\s*[>=]?\s*\d+(\.\d+)?', paper):
                paper_score += 1  # 有提及IF加分
            # 檢測是否為國際期刊
            if any(term in paper for term in ['international', 'IEEE', 'ACM', 'Springer', 'Elsevier']):
                paper_score += 1  # 國際期刊加分
        # 檢測頂級會議
        elif any(conf in paper for conf in ['ICML', 'NeurIPS', 'CVPR', 'ICCV', 'ACL', 'AAAI', 'IJCAI', 'ICASSP', 'SIGGRAPH',
                                          'NIPS', 'KDD', 'SIGIR', 'ACCV', 'ECCV', 'ICLR', 'IROS', 'COLT', 'EMNLP', 'ICRA']):
            paper_score = 3  # 頂級會議
        # 檢測國際會議
        elif any(term in paper.lower() for term in ['international conference', 'ieee conference', 'acm conference', '國際研討會', '國際會議']):
            paper_score = 2  # 國際會議
        # 檢測一般會議
        elif any(term in paper.lower() for term in ['研討會', 'conference', 'symposium', 'proceedings', 'workshop']):
            paper_score = 1  # 一般會議
        # 其他論文或期刊文章
        else:
            paper_score = 1.5  # 默認給一般期刊分數
            if any(term in paper.lower() for term in ['international', 'ieee', 'acm', 'springer', 'elsevier']):
                paper_score += 0.5  # 可能是國際期刊

        # 檢測是否有引用次數
        if re.search(r'引用\s*\d+\s*次|cited\s*\d+\s*times|citations?[\s:]*\d+', paper, re.IGNORECASE):
            paper_score += 1  # 有提及引用次數加分

        score += paper_score

    # 計算專利分數
    patents = evidence_data['patents']
    for patent in patents:
        patent_score = 0

        # 國際專利
        if any(term in patent for term in ['美國專利', '歐盟專利', '國際專利', 'PCT', 'European Patent', 'US Patent']):
            patent_score = 3  # 國際專利
        # 普通專利 (含證書號的通常是已獲得專利)
        elif '證書號' in patent or re.search(r'[A-Z]\d{5,}', patent):
            patent_score = 2  # 國內專利
        # 申請中專利
        elif '申請中' in patent or 'pending' in patent.lower():
            patent_score = 1  # 申請中專利
        else:
            patent_score = 1.5  # 其他專利相關

        score += patent_score

    # 計算其他佐證分數
    news_count = len(re.findall(r'新聞|報導|news|media|press', all_evidence, re.IGNORECASE))
    website_count = len(re.findall(r'網站|官網|website|http|www', all_evidence, re.IGNORECASE))

    score += news_count * 0.5
    score += website_count * 1

    # 檢查是否有DOI (國際識別碼通常代表較正式的出版物)
    if evidence_data['dois']:
        score += len(evidence_data['dois']) * 1

    return score
def calculate_citation_scores(df, use_direct_count=True):
    """
    批量計算論文引用分數

    Args:
        df: 包含論文資訊的DataFrame
        use_direct_count: 是否直接使用引用次數作為分數

    Returns:
        pandas.Series: 每篇論文的引用分數
    """
    print("正在計算論文引用分數...")

    # 找出佐證資料相關欄位
    evidence_cols = find_evidence_columns(df)

    if not evidence_cols:
        print("警告: 找不到佐證資料相關欄位，無法計算引用分數")
        return pd.Series([0] * len(df))

    print(f"使用以下欄位作為佐證資料來源: {evidence_cols}")

    # 儲存論文引用次數的字典 (為了避免重複計算)
    citation_counts = {}
    citation_scores = []

    # 遍歷DataFrame中的每一行
    for idx, row in df.iterrows():
        score = 0

        # 從佐證資料欄位中提取論文資訊
        all_evidence = ""
        for col in evidence_cols:
            all_evidence += str(row[col]) + " "

        # 提取論文和DOI
        evidence_data = extract_papers_and_patents(all_evidence)

        papers = evidence_data['papers']
        dois = evidence_data['dois']

        # 查詢每篇論文的引用次數
        for paper in papers:
            if paper in citation_counts:
                citation_count = citation_counts[paper]
            else:
                citation_count = query_citation_count(paper)
                citation_counts[paper] = citation_count

            # 累加分數
            score += calculate_citation_score(citation_count, use_direct_count)

        citation_scores.append(score)

        # 每處理5個項目顯示一次進度
        if (idx + 1) % 5 == 0:
            print(f"已處理 {idx + 1}/{len(df)} 個項目")

    return pd.Series(citation_scores)

#======================================================================
# 6. 排序與結果輸出
#======================================================================

def get_top_n(df, n=50):
    """
    排序並選出綜合影響力指數最高的前N項

    Args:
        df: 包含綜合影響力指數的DataFrame
        n: 要選出的項目數量，默認為50

    Returns:
        pandas.DataFrame: 包含前N項的DataFrame
    """
    # 確保n不超過資料量
    n = min(n, len(df))

    # 根據綜合影響力指數排序並選出前N項
    top_df = df.sort_values('綜合影響力指數', ascending=False).head(n)

    return top_df

def visualize_results(df, top_df):
    """
    視覺化分析結果

    Args:
        df: 原始DataFrame
        top_df: 選出的Top N DataFrame
    """
    # 設定圖形大小
    plt.figure(figsize=(15, 10))

    # 繪製綜合影響力指數分布圖
    plt.subplot(2, 2, 1)
    sns.histplot(df['綜合影響力指數'], kde=True)
    plt.title('綜合影響力指數分布')
    plt.xlabel('綜合影響力指數')
    plt.ylabel('計數')

    # 繪製各指數箱型圖
    plt.subplot(2, 2, 2)
    index_columns = ['科學突破指數', '產業應用指數', '佐證資料強度指數']
    if '論文引用分數' in df.columns and df['論文引用分數'].sum() > 0:
        index_columns.append('論文引用分數')
    sns.boxplot(data=df[index_columns])
    plt.title('各指數分布箱型圖')
    plt.ylabel('分數')
    plt.xticks(rotation=30)

    # 查找組別欄位
    group_col = None
    for col in df.columns:
        if '組別' in clean_column_name(col):
            group_col = col
            break

    # 繪製組別分布餅圖
    plt.subplot(2, 2, 3)
    if group_col:
        top_group_counts = top_df[group_col].value_counts()
        plt.pie(top_group_counts, labels=top_group_counts.index, autopct='%1.1f%%')
        plt.title('Top項目組別分布')
    else:
        plt.text(0.5, 0.5, '無法找到組別欄位', ha='center', va='center')
        plt.title('缺少組別資訊')

    # 查找年度和季別欄位
    year_col = None
    quarter_col = None

    for col in df.columns:
        col_clean = clean_column_name(col)
        if '年度' in col_clean:
            year_col = col
        elif '季' in col_clean or 'Q' in col_clean:
            quarter_col = col

    # 繪製年度和季別分布熱圖
    plt.subplot(2, 2, 4)
    if year_col and quarter_col:
        year_quarter = pd.crosstab(top_df[year_col], top_df[quarter_col])
        sns.heatmap(year_quarter, annot=True, fmt='d', cmap='YlGnBu')
        plt.title('Top項目年度季別分布')
    else:
        plt.text(0.5, 0.5, '無法找到年度或季別欄位', ha='center', va='center')
        plt.title('缺少年度季別資訊')

    plt.tight_layout()
    plt.savefig('分析結果視覺化.png', dpi=300)
    plt.show()

    # 尋找技術關鍵字欄位
    tech_col = None
    for col in df.columns:
        col_clean = clean_column_name(col)
        if '技術關鍵字' in col_clean or ('技術' in col_clean and '關鍵' in col_clean):
            tech_col = col
            break

    if not tech_col:
        for col in df.columns:
            if '技術' in clean_column_name(col):
                tech_col = col
                break

    # 繪製Top N項目的綜合影響力指數橫條圖
    if tech_col:
        plt.figure(figsize=(12, 15))
        top_plot_df = top_df.sort_values('綜合影響力指數')

        # 創建簡短標籤 (取技術關鍵字前15個字元)
        top_plot_df['簡短標籤'] = top_plot_df[tech_col].str[:15] + '...'

        # 繪製橫條圖
        sns.barplot(x='綜合影響力指數', y='簡短標籤', data=top_plot_df)
        plt.title('Top 項目綜合影響力指數')
        plt.xlabel('綜合影響力指數')
        plt.ylabel('技術關鍵字')
        plt.tight_layout()
        plt.savefig('Top項目排名.png', dpi=300)
        plt.show()

def export_results(df, top_df, output_path):
    """
    將分析結果輸出為Excel檔案

    Args:
        df: 原始DataFrame（包含所有計算的指數）
        top_df: 選出的Top N DataFrame
        output_path: 輸出檔案路徑
    """
    # 創建ExcelWriter對象
    with pd.ExcelWriter(output_path) as writer:
        # 輸出所有項目的分數
        df.to_excel(writer, sheet_name='所有項目分數', index=False)

        # 輸出Top N項目
        top_df.to_excel(writer, sheet_name='Top項目', index=False)

        # 查找組別欄位
        group_col = None
        for col in df.columns:
            if '組別' in clean_column_name(col):
                group_col = col
                break

        # 輸出各組別的統計資訊
        if group_col:
            score_cols = ['科學突破指數', '產業應用指數', '佐證資料強度指數', '綜合影響力指數']
            score_cols = [col for col in score_cols if col in df.columns]

            group_stats = df.groupby(group_col)[score_cols].mean()
            group_stats.to_excel(writer, sheet_name='組別統計')

        # 查找年度和季別欄位
        year_col = None
        quarter_col = None

        for col in df.columns:
            col_clean = clean_column_name(col)
            if '年度' in col_clean:
                year_col = col
            elif '季' in col_clean or 'Q' in col_clean:
                quarter_col = col

        # 輸出年度/季別的統計資訊
        if year_col and quarter_col:
            year_quarter_stats = df.groupby([year_col, quarter_col])['綜合影響力指數'].mean().unstack()
            year_quarter_stats.to_excel(writer, sheet_name='年度季別統計')

    print(f"分析結果已輸出至: {output_path}")

#======================================================================
# 7. 主程式流程
#======================================================================

def main():
    """
    主程式流程
    """
    print("="*60)
    print("研發計畫亮點突破排序分析程式 v1.0")
    print("="*60)

    # 設定檔案路徑
    input_file = "附件1_彙整_113年度團隊技術突破亮點案例填報表_原始資料.xlsx"
    output_file = "研發計畫亮點突破排序分析結果.xlsx"

    # 讓用戶確認檔案名稱
    print(f"預設輸入檔案: {input_file}")
    confirm_file = input("確認使用此檔案? (y/n): ").lower()
    if confirm_file != 'y':
        input_file = input("請輸入正確的Excel檔案名稱: ")

    # 讀取資料
    df = load_data(input_file)
    if df is None:
        print("讀取檔案失敗，程式結束")
        return

    # 顯示欄位名稱
    print("\n檔案中的欄位:")
    for i, col in enumerate(df.columns):
        print(f"{i+1}. {col}")

    proceed = input("\n是否繼續分析? (y/n): ").lower()
    if proceed != 'y':
        print("程式結束")
        return

    # 詢問是否計算引用分數
    use_citation = input("\n是否計算論文引用分數進行評分? (y/n): ").lower() == 'y'

    # 如果使用引用次數，詢問是否直接使用引用次數作為分數
    use_direct_count = True
    if use_citation:
        direct_count = input("是否直接以引用次數作為分數? (y/n，建議選y): ").lower() == 'y'
        use_direct_count = direct_count

    # 設定權重字典 (可以根據需求調整)
    if use_citation:
        weight_dict = {
            'breakthrough': 0.35,  # 科學突破指數權重
            'application': 0.35,   # 產業應用指數權重
            'evidence': 0.2,       # 佐證資料強度指數權重
            'citation': 0.1        # 論文引用分數權重
        }
    else:
        weight_dict = {
            'breakthrough': 0.4,  # 科學突破指數權重
            'application': 0.4,   # 產業應用指數權重
            'evidence': 0.2       # 佐證資料強度指數權重
        }

    # 顯示權重設定
    print("\n評分權重設定:")
    for category, weight in weight_dict.items():
        if category == 'breakthrough':
            print(f"科學突破指數: {weight * 100:.0f}%")
        elif category == 'application':
            print(f"產業應用指數: {weight * 100:.0f}%")
        elif category == 'evidence':
            print(f"佐證資料強度指數: {weight * 100:.0f}%")
        elif category == 'citation':
            print(f"論文引用分數: {weight * 100:.0f}%")

    # 計算各項指數
    print("\n開始計算各項指數...")

    print("正在計算科學突破指數...")
    keywords = define_keywords()
    df['科學突破指數'] = df.apply(lambda row: calculate_breakthrough_index(row, keywords), axis=1)

    print("正在計算產業應用指數...")
    df['產業應用指數'] = df.apply(lambda row: calculate_application_index(row, keywords), axis=1)

    print("正在計算佐證資料強度指數...")
    df['佐證資料強度指數'] = df.apply(calculate_evidence_index, axis=1)

    # 如果需要，計算論文引用分數
    if use_citation:
        print("正在計算論文引用分數...")
        df['論文引用分數'] = calculate_citation_scores(df, use_direct_count=use_direct_count)
    else:
        df['論文引用分數'] = 0

    # 輸出各指數的統計資訊
    print("\n各指數統計資訊:")
    for col in ['科學突破指數', '產業應用指數', '佐證資料強度指數', '論文引用分數']:
        if col in df.columns:
            print(f"{col}: 平均 {df[col].mean():.2f}, 最大 {df[col].max():.2f}, 最小 {df[col].min():.2f}")

    # 標準化各指數（將分數轉換為0-100的範圍）
    print("\n正在標準化各指數...")
    for column in ['科學突破指數', '產業應用指數', '佐證資料強度指數']:
        if df[column].max() > 0:  # 防止除以零的錯誤
            df[column] = 100 * df[column] / df[column].max()

    if use_citation and df['論文引用分數'].max() > 0:
        df['論文引用分數'] = 100 * df['論文引用分數'] / df['論文引用分數'].max()

    # 計算綜合影響力指數
    print("正在計算綜合影響力指數...")
    df['綜合影響力指數'] = (
        df['科學突破指數'] * weight_dict.get('breakthrough', 0) +
        df['產業應用指數'] * weight_dict.get('application', 0) +
        df['佐證資料強度指數'] * weight_dict.get('evidence', 0)
    )

    if use_citation:
        df['綜合影響力指數'] += df['論文引用分數'] * weight_dict.get('citation', 0)

    # 獲取Top項目數量
    n = 50
    if len(df) < 50:
        n = len(df)
        print(f"\n注意: 資料僅有 {n} 筆，將顯示所有項目")
    else:
        custom_n = input(f"\n要選出的Top項目數量 (預設50): ")
        if custom_n.isdigit() and int(custom_n) > 0:
            n = min(int(custom_n), len(df))
        else:
            print(f"使用預設值: Top {n} 項目")

    # 獲取Top N
    top_df = get_top_n(df, n=n)
    print(f"\n已選出Top {n}項目，綜合影響力指數範圍: {top_df['綜合影響力指數'].min():.2f} - {top_df['綜合影響力指數'].max():.2f}")

    # 視覺化結果
    print("\n正在生成視覺化結果...")
    visualize_results(df, top_df)

    # 輸出結果
    print("\n正在輸出結果到Excel...")
    export_results(df, top_df, output_file)

    # 顯示Top 10項目的資訊
    # 尋找技術關鍵字欄位
    tech_col = None
    for col in df.columns:
        col_clean = clean_column_name(col)
        if '技術關鍵字' in col_clean or ('技術' in col_clean and '關鍵' in col_clean):
            tech_col = col
            break

    if not tech_col:
        for col in df.columns:
            if '技術' in clean_column_name(col):
                tech_col = col
                break

    # 顯示前10項(或更少)
    display_n = min(10, len(top_df))
    print(f"\nTop {display_n}項目:")
    for i, (_, row) in enumerate(top_df.head(display_n).iterrows(), 1):
        if tech_col:
            print(f"{i}. {row[tech_col]} (綜合影響力指數: {row['綜合影響力指數']:.2f})")
        else:
            print(f"{i}. 項目 {row.get('項次', i)} (綜合影響力指數: {row['綜合影響力指數']:.2f})")

    print(f"\n分析結果已輸出至: {output_file}")
    print("="*60)
    print("分析完成!")
    print("="*60)

# 直接執行
if __name__ == "__main__":
    main()